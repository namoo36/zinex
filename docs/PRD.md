# Product Requirements Document (PRD)
## 고성능 주식 거래소 백엔드 시스템

### 1. 개요

고성능, 확장 가능한 주식 거래소 백엔드 시스템을 구축합니다. 실시간 시세 처리, 대용량 주문 처리, 빠른 검색 성능, 분산 환경에서의 데이터 일관성 보장을 핵심 목표로 합니다. 본 프로젝트는 **분산락**, **DB 튜닝**, **NoSQL**, **Elasticsearch**, **HikariCP 최적화**, **쓰레드 덤프 분석** 등의 핵심 기술 학습을 목적으로 합니다.

### 2. 비즈니스 목표

- **고가용성**: 99.9% 이상의 서비스 가용성 유지
- **확장성**: 수평 확장 가능한 아키텍처
- **성능**: API 응답 시간 50ms 이하 (P95) - 거래소 특성상 매우 빠른 응답 필요
- **데이터 일관성**: 분산 환경에서의 트랜잭션 일관성 보장 (잔고, 주문 체결)
- **실시간성**: 시세 데이터 실시간 처리 및 전달
- **모니터링**: 실시간 성능 모니터링 및 쓰레드 덤프 분석

### 3. 핵심 기능 요구사항

#### 3.1 회원 관리
- 회원가입 (이메일, 비밀번호)
- 로그인/로그아웃
- JWT 기반 인증 (Access Token, Refresh Token)
- 회원 정보 조회 및 수정
- 계좌 정보 관리 (계좌번호, 잔고)
- **원화 입금**: 사용자가 원화를 입금하여 예수금 확보

#### 3.2 종목 관리
- 종목 정보 CRUD (종목코드, 종목명, 시장구분 등)
- 종목 상세 정보 조회
- 종목 리스트 조회 (페이징)
- 종목 검색 (Elasticsearch 활용)
- 종목 검색 자동완성
- 관심 종목 등록/해제

#### 3.3 실시간 시세 관리
- 현재가 조회
- 호가창 조회 (매수/매도 호가)
- 체결가 조회
- 일봉/분봉 데이터 조회
- 시세 이력 조회
- 시세 데이터 실시간 업데이트 (WebSocket 또는 SSE)

#### 3.4 주문 관리
- 매수 주문 (지정가/시장가)
  - **매수 주문 시 주문 금액만큼 '주문 가능 금액'에서 즉시 Hold 처리**
  - Hold 처리 시 분산락을 활용한 동시성 제어
  - 주문 가능 금액 부족 시 주문 실패
- 매도 주문 (지정가/시장가)
- 주문 조회 (미체결/체결/전체)
- 주문 취소
  - **주문 취소 시 Hold 된 금액 즉시 복구 (주문 가능 금액에 반영)**
  - 분산락을 활용한 안전한 Hold 해제
- 주문 수정 (가격, 수량)
  - 수량/가격 변경 시 Hold 금액 재계산 및 조정
- 주문 이력 조회

#### 3.5 체결 관리
- 주문 체결 처리 (매칭 엔진)
  - **체결 성공 시**:
    - Hold 된 금액을 실제 잔액에서 차감
    - Hold 금액 해제 처리
    - 분산락을 활용한 안전한 잔고 업데이트
    - **MongoDB에 거래 로그 저장** (체결 정보, 타임스탬프, 사용자 정보 등)
  - **체결 실패 시**:
    - Hold 된 금액 즉시 복구 (주문 가능 금액에 반영)
    - Hold 해제 처리
- 체결 내역 조회
- 체결 이력 조회
- 체결 통계 (일별, 월별)

#### 3.6 잔고 관리
- 보유 종목 조회
- 계좌 잔고 조회
  - **예수금**: 사용자가 입금한 실제 잔액
  - **주문 가능 금액**: 예수금 - Hold 금액 (매수 주문 가능한 금액)
  - **Hold 금액**: 매수 주문으로 인해 임시 차감된 금액
- 평가 손익 조회
- 매수 평균가 조회
- **분산락을 활용한 잔고 동시성 제어** (중복 체결 방지)
  - 예수금 업데이트 시 분산락 적용
  - Hold 금액 업데이트 시 분산락 적용
  - 주문 가능 금액 계산 시 동시성 제어

#### 3.7 거래 내역
- 체결 내역 조회 (일별, 월별)
  - PostgreSQL에서 기본 거래 내역 조회
  - MongoDB에서 상세 거래 로그 조회 (체결 상세 정보)
- 거래 통계 조회
- 수수료 계산 및 조회
- **MongoDB 거래 로그**:
  - 체결 성공 시 자동으로 MongoDB에 거래 로그 저장
  - 로그 구조: 체결 정보, 타임스탬프, 사용자 ID, 종목 정보, 체결 가격/수량 등
  - TTL 인덱스 활용으로 오래된 로그 자동 삭제 (선택적)

#### 3.8 검색 기능
- 종목명/종목코드 검색 (Elasticsearch)
- 검색 자동완성
- 검색 필터링 (시장구분, 업종 등)
- 인기 검색어

#### 3.9 예수금 관리 상세 로직

##### 3.9.1 예수금 구조
- **예수금 (Deposit)**: 사용자가 입금한 실제 잔액 (PostgreSQL 저장)
- **Hold 금액 (Hold Amount)**: 매수 주문으로 인해 임시 차감된 금액 (PostgreSQL 저장)
- **주문 가능 금액 (Available Balance)**: 예수금 - Hold 금액 (계산값)

##### 3.9.2 입금 프로세스
1. 사용자가 원화 입금 요청
2. 예수금 증가 (PostgreSQL 업데이트)
3. 분산락을 활용한 안전한 예수금 업데이트
4. 입금 내역 로그 저장

##### 3.9.3 매수 주문 프로세스
1. 주문 가능 금액 확인 (예수금 - Hold 금액)
2. 주문 금액이 주문 가능 금액 이하인지 검증
3. **Hold 금액 증가** (분산락 적용)
4. 주문 생성 (미체결 상태)
5. 주문 가능 금액 자동 감소 (예수금은 유지)

##### 3.9.4 주문 취소 프로세스
1. 주문 취소 요청
2. 해당 주문의 Hold 금액 확인
3. **Hold 금액 감소** (분산락 적용)
4. 주문 상태를 '취소'로 변경
5. 주문 가능 금액 자동 증가

##### 3.9.5 체결 성공 프로세스
1. 주문 체결 성공
2. **Hold 금액 감소** (분산락 적용)
3. **예수금 감소** (실제 잔액 차감, 분산락 적용)
4. 보유 종목 업데이트
5. **MongoDB에 거래 로그 저장** (비동기 처리 권장)
   - 체결 정보, 타임스탬프, 사용자 ID, 종목 정보, 체결 가격/수량, 수수료 등

##### 3.9.6 체결 실패 프로세스
1. 주문 체결 실패 (예: 주문 만료, 시스템 오류 등)
2. **Hold 금액 감소** (분산락 적용)
3. 주문 상태를 '실패' 또는 '만료'로 변경
4. 주문 가능 금액 자동 증가

##### 3.9.7 동시성 제어
- 모든 예수금/Hold 금액 업데이트는 **분산락(Redis)**을 활용하여 동시성 제어
- 사용자별 락 키 사용 (예: `lock:balance:{userId}`)
- 락 타임아웃 설정 (기본 5초)
- 락 획득 실패 시 재시도 로직 (최대 3회)

### 4. 비기능 요구사항

#### 4.1 성능
- **API 응답 시간**: P95 기준 50ms 이하 (주문/체결 API는 10ms 이하)
- **동시 사용자**: 5,000+ 동시 접속 지원
- **초당 트랜잭션**: 10,000+ TPS 처리 가능 (주문 처리)
- **검색 응답 시간**: 30ms 이하
- **시세 조회 응답 시간**: 20ms 이하

#### 4.2 확장성
- 수평 확장 가능한 아키텍처
- 마이크로서비스 기반 설계
- 로드 밸런싱 지원
- 데이터베이스 샤딩 지원 (종목별, 사용자별)

#### 4.3 가용성
- 99.9% 이상 가용성 목표
- 장애 복구 시간: 3분 이내 (거래소 특성상 중요)
- 데이터 백업 및 복구 전략
- 무중단 배포 지원

#### 4.4 보안
- **Spring Security + JWT** 기반 인증/인가
- 데이터 암호화 (전송 중, 저장 시)
- SQL Injection 방지
- XSS 방지
- Rate Limiting (주문 API 보호)
- 계좌 정보 접근 제어

#### 4.5 모니터링 및 관찰성
- 실시간 성능 메트릭 수집
- 로그 집계 및 분석
- 분산 추적 (Distributed Tracing)
- 알림 시스템
- **쓰레드 덤프 자동 수집 및 분석** (핵심 학습 목표)
- APM (Application Performance Monitoring) 통합
- **HikariCP 커넥션 풀 모니터링**

### 5. 기술적 제약사항 및 학습 목표

#### 5.1 데이터베이스

**MVP 단계 (Phase 0)**:
- **MySQL**: 
  - 모든 데이터 저장 (회원, 종목, 주문, 체결, 잔고 등)
  - 기본 CRUD 기능 구현
  - 기본 인덱스 설정

**최종 목표 (Phase 2+)**:
- **PostgreSQL**: 
  - 관계형 데이터 (주문, 체결, 잔고, 사용자)
  - **DB 튜닝 학습**: 인덱스 최적화, 쿼리 최적화, 파티셔닝
  - MySQL에서 마이그레이션
- **MongoDB**: 
  - 비정형 데이터 (시세 데이터, 로그, 이벤트)
  - **거래 로그**: 체결 성공 시 거래 상세 정보 저장
  - **NoSQL 학습**: 문서 모델 설계, 샤딩, TTL 인덱스
- **Elasticsearch**: 
  - 검색 엔진 (종목 검색)
  - **검색 엔진 학습**: 인덱스 설계, 분석기 커스터마이징, 쿼리 최적화

#### 5.2 분산락 (핵심 학습 목표)
- **Redis 기반 분산락**:
  - 예수금 업데이트 시 동시성 제어
  - Hold 금액 업데이트 시 동시성 제어
  - 주문 체결 시 중복 처리 방지
  - 계좌 잔고 조회/업데이트 동시성 제어
- **사용 시나리오**:
  - 원화 입금 시 예수금 업데이트
  - 매수 주문 시 Hold 금액 증가
  - 주문 취소 시 Hold 금액 감소
  - 체결 성공 시 예수금 차감 및 Hold 금액 해제
  - 체결 실패 시 Hold 금액 해제
  - 동일 주문 중복 체결 방지

#### 5.3 HikariCP 최적화 (핵심 학습 목표)
- **연결 풀 튜닝**:
  - 최소/최대 커넥션 수 설정
  - 커넥션 타임아웃 설정
  - 커넥션 유효성 검사
  - 커넥션 풀 모니터링 및 메트릭 수집
- **최적화 전략**:
  - 트래픽 패턴 분석
  - 커넥션 풀 사용률 모니터링
  - 슬로우 쿼리 감지 및 최적화

#### 5.4 쓰레드 덤프 분석 (핵심 학습 목표)
- **자동 수집**:
  - 정기적 쓰레드 덤프 (5분 간격)
  - CPU 사용률 80% 초과 시 자동 수집
  - 메모리 사용률 85% 초과 시 자동 수집
  - 응답 시간 급증 시 자동 수집
- **분석 도구**:
  - Thread Dump Analyzer (TDA)
  - IBM Thread and Monitor Dump Analyzer
  - VisualVM
- **통합**:
  - Prometheus AlertManager와 연동
  - Grafana 대시보드에 쓰레드 상태 표시
  - 쓰레드 덤프 분석 리포트 자동 생성

### 6. 성능 튜닝 고려사항

#### 6.1 데이터베이스 튜닝

**MVP 단계 (MySQL)**:
- 기본 인덱스 설정 (Primary Key, Foreign Key)
- 기본 쿼리 최적화
- EXPLAIN 활용한 쿼리 분석
- 커넥션 풀 튜닝 (HikariCP)

**최종 목표 (PostgreSQL)**:
- 인덱스 최적화 (복합 인덱스, 부분 인덱스)
- 쿼리 최적화 (EXPLAIN ANALYZE 활용)
- 파티셔닝 (주문 테이블 날짜별, 체결 테이블 종목별)
- 읽기 전용 복제본 (Read Replica)
- 커넥션 풀 튜닝 (HikariCP)
- VACUUM 및 ANALYZE 전략
- **MongoDB**:
  - 인덱스 설계 (복합 인덱스)
  - 샤딩 전략 (시세 데이터)
  - TTL 인덱스 (로그 데이터 자동 삭제)
  - Write Concern 최적화
- **Elasticsearch**:
  - 인덱스 템플릿 설계
  - 분석기 커스터마이징 (한글 형태소 분석)
  - 샤딩 및 레플리카 설정
  - 검색 쿼리 최적화

#### 6.2 애플리케이션 레벨 튜닝
- 비동기 처리 (WebFlux, CompletableFuture)
- 캐싱 전략 (Redis)
  - 종목 정보 캐싱
  - 시세 데이터 캐싱
  - 사용자 정보 캐싱
- 배치 처리 (체결 내역 집계)
- N+1 쿼리 문제 해결
- 불필요한 직렬화/역직렬화 최소화

#### 6.3 JVM 튜닝
- 힙 크기 최적화 (-Xms, -Xmx)
- GC 알고리즘 선택 및 튜닝 (G1GC 권장)
- GC 로그 설정 및 분석
- 쓰레드 풀 크기 최적화
- JIT 컴파일러 최적화

### 7. 모니터링 및 분석

#### 7.1 애플리케이션 메트릭
- **Prometheus**:
  - API 응답 시간 (P50, P95, P99)
  - 요청 처리량 (RPS)
  - 에러율
  - 활성 쓰레드 수
  - JVM 메트릭 (GC, 힙, 쓰레드)
  - **HikariCP 커넥션 풀 메트릭** (활성 커넥션, 대기 중인 커넥션, 타임아웃)

#### 7.2 데이터베이스 메트릭
- 쿼리 실행 시간
- 커넥션 풀 사용률
- 슬로우 쿼리 감지
- 트랜잭션 처리량
- 락 대기 시간

#### 7.3 로깅
- **ELK Stack** (Elasticsearch, Logstash, Kibana)
  - 중앙화된 로그 수집
  - 로그 분석 및 검색
  - 로그 기반 알림
- 구조화된 로깅 (JSON)
- 비동기 로깅

#### 7.4 분산 추적
- **Jaeger** 또는 **Zipkin**
  - 마이크로서비스 간 요청 추적
  - 성능 병목 지점 식별

#### 7.5 쓰레드 덤프 분석
- **자동 수집**:
  - 정기적 쓰레드 덤프 (5분 간격)
  - CPU 사용률 80% 초과 시
  - 메모리 사용률 85% 초과 시
  - 응답 시간 급증 시
- **분석**:
  - 데드락 감지
  - 쓰레드 풀 고갈 감지
  - 블로킹 I/O 감지
  - CPU 사용률 높은 쓰레드 식별
- **리포트**:
  - 일일 쓰레드 덤프 분석 리포트
  - 이상 징후 알림

### 8. 성공 지표 (KPI)

#### 8.1 성능 지표
- API 응답 시간 (P50, P95, P99)
- 주문 처리 응답 시간 (P95 < 10ms)
- 체결 처리 응답 시간 (P95 < 5ms)
- 검색 응답 시간 (P95 < 30ms)
- 시세 조회 응답 시간 (P95 < 20ms)

#### 8.2 안정성 지표
- 에러율 (5xx 에러 < 0.1%)
- 가용성 (99.9% 이상)
- MTTR (Mean Time To Recovery) < 3분

#### 8.3 처리량 지표
- 초당 트랜잭션 (TPS) > 10,000
- 동시 주문 처리 수
- 체결 처리량

#### 8.4 리소스 지표
- CPU 사용률
- 메모리 사용률
- 디스크 I/O
- **HikariCP 커넥션 풀 사용률** (목표: 70% 이하)
- **쓰레드 풀 사용률** (목표: 80% 이하)
- GC 시간 및 빈도

#### 8.5 데이터베이스 지표
- 쿼리 실행 시간
- 커넥션 풀 사용률
- 슬로우 쿼리 수
- 락 대기 시간

### 9. 핵심 기술 학습 시나리오

#### 9.1 분산락 학습 시나리오
1. **문제 상황**: 
   - 동시에 여러 주문이 체결될 때 예수금 중복 차감 문제
   - 동시에 여러 매수 주문이 들어올 때 Hold 금액 중복 차감 문제
   - 주문 취소와 체결이 동시에 발생할 때 Hold 금액 불일치 문제
2. **해결 방법**: Redis 기반 분산락으로 예수금/Hold 금액 업데이트 동시성 제어
3. **학습 포인트**:
   - Redisson RLock 사용
   - TTL 설정으로 데드락 방지
   - 락 타임아웃 처리
   - 사용자별 락 키 전략
   - 락 성능 측정 및 최적화
   - Hold 금액과 예수금 업데이트의 원자성 보장

#### 9.2 DB 튜닝 학습 시나리오
1. **문제 상황**: 
   - MVP 단계: 주문 조회 API 응답 시간이 느림 (500ms 이상)
   - MySQL에서 기본 쿼리 최적화 필요
2. **해결 방법**: 
   - MySQL EXPLAIN으로 쿼리 분석
   - 인덱스 추가/수정
   - 쿼리 최적화
   - Phase 2에서 PostgreSQL로 마이그레이션 후 고급 기능 활용
   - PostgreSQL EXPLAIN ANALYZE로 쿼리 분석
   - 파티셔닝 적용
3. **학습 포인트**:
   - MySQL 기본 인덱스 전략
   - 쿼리 실행 계획 분석 (EXPLAIN)
   - MySQL → PostgreSQL 마이그레이션
   - PostgreSQL 고급 기능 (파티셔닝, 복제본)
   - 성능 측정 및 비교

#### 9.3 NoSQL 학습 시나리오
1. **문제 상황**: 
   - 시세 데이터가 빠르게 증가하여 PostgreSQL 부하 증가
   - 체결 로그가 대량으로 쌓여 PostgreSQL 성능 저하
2. **해결 방법**: 
   - MongoDB로 시세 데이터 이관
   - MongoDB로 거래 로그 저장 (체결 성공 시)
3. **학습 포인트**:
   - 문서 모델 설계 (시세 데이터, 거래 로그)
   - 인덱스 설계 (사용자 ID, 종목 코드, 타임스탬프 등)
   - TTL 인덱스 활용 (오래된 로그 자동 삭제)
   - 샤딩 전략 (사용자별 또는 종목별)
   - 비동기 로그 저장 (성능 최적화)

#### 9.4 Elasticsearch 학습 시나리오
1. **문제 상황**: 종목 검색이 느리고 LIKE 쿼리로 인한 DB 부하
2. **해결 방법**: Elasticsearch로 검색 기능 이관
3. **학습 포인트**:
   - 인덱스 매핑 설계
   - 분석기 커스터마이징
   - 검색 쿼리 최적화
   - 자동완성 구현

#### 9.5 HikariCP 최적화 학습 시나리오
1. **문제 상황**: 커넥션 풀 고갈로 인한 타임아웃 발생
2. **해결 방법**: 
   - 커넥션 풀 크기 조정
   - 커넥션 타임아웃 설정
   - 커넥션 유효성 검사 설정
   - 모니터링 강화
3. **학습 포인트**:
   - 커넥션 풀 파라미터 이해
   - 트래픽 패턴 분석
   - 커넥션 풀 메트릭 분석
   - 최적 크기 산정

#### 9.6 쓰레드 덤프 분석 학습 시나리오
1. **문제 상황**: CPU 사용률이 높고 응답 시간이 느려짐
2. **해결 방법**:
   - 쓰레드 덤프 수집
   - 쓰레드 상태 분석
   - 블로킹 지점 식별
   - 병목 지점 최적화
3. **학습 포인트**:
   - 쓰레드 덤프 읽기
   - 데드락 감지
   - 쓰레드 풀 고갈 감지
   - CPU 사용률 높은 쓰레드 식별
   - 분석 도구 활용

### 10. 향후 확장 계획

- 실시간 알림 시스템 (WebSocket)
- 차트 데이터 제공 (캔들스틱, 라인 차트)
- 기술적 지표 계산 (이동평균, RSI 등)
- 백테스팅 시스템
- 포트폴리오 분석
- 뉴스/공시 연동
- 모바일 앱 API
- 다중 거래소 연동

### 11. 위험 요소 및 대응 방안

#### 11.1 기술적 위험
- **데이터 일관성**: 분산락 실패 시 잔고 불일치
  - 대응: 분산락 재시도 로직, 정합성 검증 배치 작업
- **성능 저하**: 트래픽 급증 시 응답 시간 증가
  - 대응: 오토스케일링, 캐싱 강화, 로드 밸런싱
- **데이터베이스 부하**: 쿼리 성능 저하
  - 대응: 인덱스 최적화, 읽기 전용 복제본, 쿼리 최적화

#### 11.2 운영 위험
- **장애 복구**: 시스템 장애 시 빠른 복구 필요
  - 대응: 모니터링 강화, 자동 알림, 롤백 전략
- **데이터 손실**: 트랜잭션 데이터 손실 방지
  - 대응: 정기 백업, 트랜잭션 로그 보관, 복구 테스트

### 12. 개발 단계

#### Phase 0: MVP 개발 (초기 단계)
**기술 스택**: MySQL + Spring Boot + Java + Redis

**목표**: 기초 CRUD 기능 구현 및 핵심 비즈니스 로직 검증

**구현 내용**:
- 회원 관리 (Spring Security + JWT)
  - 회원가입, 로그인, 로그아웃
  - JWT 토큰 발급 및 검증
- 종목 관리 (기본 CRUD)
  - 종목 정보 등록/조회/수정/삭제
  - 종목 리스트 조회 (페이징)
- 계좌 관리
  - 원화 입금 (예수금 증가)
  - 예수금 조회
  - 주문 가능 금액 조회
- 주문 관리 (기본 CRUD)
  - 매수 주문 생성
  - 매도 주문 생성
  - 주문 조회 (미체결/체결/전체)
  - 주문 취소
  - Hold 금액 처리 로직 구현
- 체결 관리 (기본 로직)
  - 체결 처리 (간단한 매칭 로직)
  - 체결 내역 조회
  - Hold 금액 해제 및 예수금 차감
- 잔고 관리
  - 보유 종목 조회
  - 계좌 잔고 조회
- **Redis 활용**:
  - 분산락 구현 (예수금/Hold 금액 동시성 제어)
  - 세션 관리 (선택적)
  - 캐싱 (종목 정보 등)

**데이터베이스**:
- MySQL: 모든 데이터 저장 (회원, 종목, 주문, 체결, 잔고 등)
- Redis: 분산락, 캐싱

**학습 포인트**:
- Spring Boot 기본 구조 이해
- JPA/Hibernate를 활용한 CRUD 구현
- MySQL 기본 쿼리 및 인덱스
- Redis 분산락 구현
- 트랜잭션 관리

#### Phase 1: 성능 최적화 및 DB 튜닝
**기술 스택**: MySQL + Spring Boot + Java + Redis + HikariCP

**목표**: 성능 최적화 및 DB 튜닝 학습

**구현 내용**:
- MySQL DB 튜닝
  - 인덱스 최적화 (복합 인덱스, 부분 인덱스)
  - 쿼리 최적화 (EXPLAIN ANALYZE 활용)
  - 슬로우 쿼리 분석 및 개선
- HikariCP 최적화
  - 커넥션 풀 크기 조정
  - 커넥션 타임아웃 설정
  - 커넥션 풀 모니터링
- 캐싱 전략 강화
  - 종목 정보 캐싱 (Redis)
  - 사용자 정보 캐싱
- 분산락 고도화
  - 락 성능 측정 및 최적화
  - 락 타임아웃 처리 개선

**학습 포인트**:
- MySQL 인덱스 전략
- 쿼리 실행 계획 분석
- HikariCP 커넥션 풀 튜닝
- 성능 측정 및 비교

#### Phase 2: PostgreSQL 마이그레이션 및 고도화
**기술 스택**: PostgreSQL + Spring Boot + Java + Redis + HikariCP

**목표**: PostgreSQL로 마이그레이션 및 고급 기능 구현

**구현 내용**:
- PostgreSQL 마이그레이션
  - MySQL에서 PostgreSQL로 데이터 마이그레이션
  - PostgreSQL 특화 기능 활용 (JSON 타입, 배열 등)
- PostgreSQL 고급 기능
  - 파티셔닝 (주문 테이블 날짜별)
  - 읽기 전용 복제본 (Read Replica)
  - 트리거 및 함수 활용
- 고급 주문 기능
  - 주문 수정 (가격, 수량)
  - 복잡한 주문 조회 필터링
- 체결 로직 고도화
  - 매칭 엔진 개선
  - 체결 통계 (일별, 월별)

**학습 포인트**:
- PostgreSQL vs MySQL 차이점
- 파티셔닝 전략
- 읽기 전용 복제본 활용

#### Phase 3: 검색 및 NoSQL 도입
**기술 스택**: PostgreSQL + MongoDB + Elasticsearch + Spring Boot + Java + Redis

**목표**: NoSQL 및 검색 엔진 학습

**구현 내용**:
- Elasticsearch 통합
  - 종목 검색 기능 구현
  - 검색 자동완성
  - 검색 필터링 고도화
- MongoDB 통합
  - 시세 데이터 MongoDB 저장
  - 거래 로그 MongoDB 저장 (체결 성공 시)
  - TTL 인덱스 활용
- 검색 기능 고도화
  - 인기 검색어
  - 검색 분석

**학습 포인트**:
- Elasticsearch 인덱스 설계
- MongoDB 문서 모델 설계
- 검색 쿼리 최적화
- TTL 인덱스 활용

#### Phase 4: 모니터링 및 분석
**기술 스택**: PostgreSQL + MongoDB + Elasticsearch + Spring Boot + Java + Redis + Prometheus + Grafana

**목표**: 모니터링 및 성능 분석 체계 구축

**구현 내용**:
- Prometheus + Grafana 설정
  - 애플리케이션 메트릭 수집
  - JVM 메트릭 수집
  - HikariCP 커넥션 풀 메트릭
  - 대시보드 구성
- 쓰레드 덤프 자동 수집
  - 정기적 쓰레드 덤프 수집
  - CPU/메모리 임계값 초과 시 자동 수집
  - 쓰레드 덤프 분석 도구 통합
- 성능 분석 도구 통합
  - APM 도구 연동
  - 분산 추적 (Jaeger/Zipkin)
- 로깅 강화
  - ELK Stack 통합
  - 구조화된 로깅

**학습 포인트**:
- Prometheus 메트릭 수집
- Grafana 대시보드 구성
- 쓰레드 덤프 분석
- 성능 병목 지점 식별

#### Phase 5: 고도화 및 확장
**목표**: 실시간 기능 및 고급 기능 구현

**구현 내용**:
- 실시간 시세 (WebSocket)
- 차트 데이터 제공
- 기술적 지표 계산
- 백테스팅 시스템
- 포트폴리오 분석
- 성능 테스트 및 튜닝
